{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Webserver com Servidor TFTP para automatiza\u00e7\u00e3o de deploy de testes de Embarcados na DE10-Standard \u00b6 Alunos: Francisco Pinheiro Janela / Wilgner / Marco Curso: Engenharia da Computa\u00e7\u00e3o / Mecatr\u00f4nica / Mecatr\u00f4nica Semestre: 6 Contato: francisco.pinheiro.janela@gmail.com / placeholder@gmail.com / placeholder@gmail.com Ano: 2022.2 Come\u00e7ando \u00b6 Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard NUC ou m\u00e1quina para server Linux Roteador ( modelo usado: tp-link TL-R470T+) Switch ( modelo usado: D-Link DGS-1100-08P) Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf , U-Boot Script , U-Boot TFTP e NFS Laborat\u00f3rios: Linux embarcado , Configurando infra , Extra: configurando rede , Compilando o kernel e Buildroot . Montando a Infraestrutura \u00b6 Para montar a infraestrutura para este roteiro vamos precisar de um ponto de acesso \u00e0 rede via cabo. Al\u00e9m disso, como a rede do insper \u00e9 protegida, o roteador que estar\u00e1 constituindo nosso kit precisa estar com o MAC Adress configurado na rede interna. Com essas condi\u00e7\u00f5es podemos, ent\u00e3o, ligar toda a fia\u00e7\u00e3o: Roteador - Porta WAN1 deve estar conectada ao ponto de acesso, a porta LAN1 ao Switch e aliment\u00e1-lo com energia Switch - M\u00ednimo de 4 portas, deve aliment\u00e1-lo com energia NUC - Conectar o cabo LAN ao Switch, ligar com Cabo USB a NUC \u00e0 DE10-Standard e aliment\u00e1-la com energia DE10-Standard - Conectar via cabo LAN ao Switch, conectar o USB da NUC, inserir o SDCard configurado com linux kernel e buildroot como filesystem (laborat\u00f3rios previamente feitos) e aliment\u00e1-la com energia Ap\u00f3s tudo conectado, com um palito ou objeto fino, clicar nos pontos de RESET tanto do Roteador, quanto do Switch. O resultado deve ficar similar ao esquema abaixo: Configurando a Infraestrtura \u00b6 Com a infra montada, podemos come\u00e7ar a configurar todos os servi\u00e7os. Vamos come\u00e7ar pela infraestrutura de Rede Configurando a Rede \u00b6 Conecte seu computador ao switch e configure sua rede para aquela estabelecida no manual do fabricante do Roteador (no caso deste modelo, a rede \u00e9 192.168.0.0/24) Entre na dashboard do roteador em 192.168.0.1 e, acessando pelas credenciais padr\u00f5es indicadas no manual, configure a m\u00e1cara de rede ( Netmask ) para 255.255.240.0 ou /20 Reconfigure seu computador agora para a rede padr\u00e3o do Switch (no caso deste modelo \u00e9 10.0.0.0/8) Acesse o Dashboard (10.90.90.90) com as credenciais default e reconfigure o Switch com o IP: 192.168.0.2/20 Configurando a M\u00e1quina \u00b6 Depois de configurar tudo de rede, podemos configurar a NUC: Conecte um monitor e um teclado \u00e0 NUC para realizar a instala\u00e7\u00e3o do S.O. Instale o Ubuntu Server 20.04 LTS e durante as configura\u00e7\u00f5es preencher com as informa\u00e7\u00f5es abaixo: hostname: nucsoc login: nucsoc senha: socfpga IP Fixo: 192.168.0.3/20 Verifique se ele consegue pingar 8.8.8.8 . Se n\u00e3o conseguir, descubra como rotear os pacotes corretamente. Verifique se ele consegue pingar www.google.com . Se n\u00e3o conseguir, descubra como resolver as urls corretamente. Verifique se consegue conectar a ela via ssh do seu computador: ssh nucsoc@192.168.0.3 Atualize o apt : sudo apt update && sudo apt upgrade -y Tip Configure a NAT no roteador para poder acessar remotamente a NUC dentro da rede do Insper. Para isso, configure no roteador: Porta externa: 22 Porta interna: 22 IP interno: 192.168.0.3 Configurando a Placa FPGA \u00b6 Seguindo os tutoriais dos roteiros da mat\u00e9ria, configure o SDCard com todas as parti\u00e7\u00f5es necess\u00e1rias, s\u00e3o elas: U-Boot (configurado com a instala\u00e7\u00e3o do linux embarcado), S.O. e Filesystem (buildroot deve estar instalado com todas as depend\u00eancias de python declaradas mais \u00e0 frente). Com tudo configurado, acesse o terminal da NUC via ssh e com o comando de screen acesse a Placa conectada a ela. sudo screen /dev/ttyUSB0 115200,cs8 Se voc\u00ea configurou NAT, \u00e9 capaz de acessar a screen da FPGA \u00e0 dist\u00e2ncia! Com esse acesso, agora podemos configurar o ip fixo do S.O. da FPGA: Acesse a pasta /etc/init.d/ Crie um arquivo chamado S60MAC.sh Info Todo o arquivo dentro desta pasta que come\u00e7a com S mai\u00fasculo \u00e9 executado durante o boot do S.O. Acessando o arquivo com vi , coloque o seguinte c\u00f3digo: #!/bin/bash case \" $1 \" in start ) printf \"Setting ip: \" /sbin/ifconfig eth0 192 .168.0.40 netmask 255 .255.240.0 up [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" route add default gw 192 .168.0.1 ;; * ) exit 1 ;; esac O c\u00f3digo acima ir\u00e1 configurar a rede da placa para que esta tenha um ip fixo de acordo com as configura\u00e7\u00f5es de rede feitas. Transforme o arquivo acima em um execut\u00e1vel chmod +x S60MAC.sh Reinicie a FPGA para aplicar as mudan\u00e7as Pronto! Agora temos toda a inffraestrutura configurada e podemos come\u00e7ar a construir nosso servidor de TFTP. Warning N\u00e3o continue para os pr\u00f3ximos passos sem toda a infraestrutura montada e configurada Servidor TFTP \u00b6 Antes de come\u00e7ar a constru\u00e7\u00e3o do servidor, \u00e9 bom entender como ele funciona. Conceito e Diret\u00f3rio \u00b6 Um servidor TFTP \u00e9 um servi\u00e7o dispon\u00edvel em um host que permite ao server buscar arquivos, baseado no protocolo de comunica\u00e7\u00e3o TFTP. Para esta aplica\u00e7\u00e3o, o servidor ser\u00e1 utilizado como fonte dos arquivos principais para configurar a FPGA da DE10-Standard, mas poderia tamb\u00e9m ser usado para buscar as imagens dos Sistemas Operacionais e BootScripts, al\u00e9m de parear muito bem com o servi\u00e7o de NFS (Network File System) para que o File System da DE10 pudesse ser remoto. Com tais funcionalidades, poder\u00edamos chegar em uma constru\u00e7\u00e3o de diret\u00f3rio assim: /srv \u251c\u2500\u2500 nfs \u2502 \u251c\u2500\u2500 angstrom-v2014.12 \u2502 \u2502 \u2514\u2500\u2500 root file system extracted from build tools .tar.gx archive \u2502 \u251c\u2500\u2500 ubuntu-core \u2502 \u2502 \u2514\u2500\u2500 root file system extracted from build tools .tar.gx archive \u2514\u2500\u2500 tftp \u251c\u2500\u2500 bootscripts \u2502 \u251c\u2500\u2500 sockit-angstrom.scr \u2502 \u251c\u2500\u2500 sockit-angstrom.script \u2502 \u251c\u2500\u2500 sockit-ubuntu.scr \u2502 \u2514\u2500\u2500 sockit-ubuntu.script \u251c\u2500\u2500 kernel \u2502 \u251c\u2500\u2500 kernel-3.10-ltsi \u2502 \u2502 \u2514\u2500\u2500 zImage \u2502 \u251c\u2500\u2500 kernel-4.4 \u2502 \u2502 \u2514\u2500\u2500 zImage \u251c\u2500\u2500 my-custom-board \u2502 \u251c\u2500\u2500 my-custom.dtb \u2502 \u2514\u2500\u2500 my-custom.rbf \u2514\u2500\u2500 sockit \u251c\u2500\u2500 soc_system.dtb \u2514\u2500\u2500 soc_system.rbf Como neste tutorial s\u00f3 ser\u00e1 usado o espa\u00e7o destinado aos arquivos do quartus, abaixo est\u00e1 uma tabela onde estes se encontram no output de uma compila\u00e7\u00e3o do projeto criado pelo aplicativo: Item Source File Location Copy to server directory Compressed FPGA configuration file Quartus GHRD Build /sockit_ghrd/output_files/soc_system.rbf soc_system.rbf Device Tree Blob file Quartus GHRD Build /sockit_ghrd/soc_system.dtb soc_system.dtb Setup do Servidor TFTP \u00b6 Para come\u00e7ar com o setup, vamos instalar o pr\u00f3prio servi\u00e7o de TFTP: sudo apt-get install tftpd-hpa Note O servidor deve come\u00e7ar autom\u00e1ticamente ap\u00f3s ser instalado, verifique por meio do seguinte comando: sudo service tftpd-hpa status Caso n\u00e3o tenha iniciado, inicie-o com o comando: sudo service tftpd-hpa start Em seguida crie os reposit\u00f3rios necess\u00e1rios para armazenar os arquivos .dtb e .rbf como mostrado na \u00e1rvore de diret\u00f3rios acima. Depois de ter organizado todo o diret\u00f3rio, precisa indicar para o servidor que s\u00e3o estas pastas que ser\u00e3o usadas. Para isso deve editar a vari\u00e1vel TFTP_DIRECTORY , localizada em /etc/default/tftpd-hpa . Ela deve possuir um diret\u00f3rio padr\u00e3o, mas deve configur\u00e1-lo para aquele criado acima. TFTP_DIRECTORY = \"/srv/tftp/\" Verifique o status novamente. Se estiver rodadndo ( start/running ), pode proceguir para a pr\u00f3xima etapa, caso n\u00e3o, provavelmente o diret\u00f3rio configurado n\u00e3o foi encontrado pelo servidor. Por \u00faltimo, copie os arquivos .dtb e .rbf para o reposit\u00f3rio e reinicie o servidor: sudo service tftpd-hpa restart Carregando o U-Boot \u00b6 Depois de configurar toda a infraestrutura da DE10-Standard com os laborat\u00f3rios feitos em aula, vamos entender uma ferramenta essencial para o funcionamento do Linux Embarcado: o U-Boot . Quando o kernel Linux \u00e9 instalado, \u00e9 criada uma parti\u00e7\u00e3o no SDCard com esse servi\u00e7o de \"pre-boot\" . Nele, s\u00e3o definidas as configura\u00e7\u00f5es iniciais da placa para receber e organizar tanto a imagem, os arquivos da FPGA e o File System e por meio de Scripts de boot, iniciar o S.O. adequadamente. Esse \"pre-boot\" \u00e9 extremamente poderoso para a nossa aplica\u00e7\u00e3o, pois podemos configurar toda a estrutura do S.O. sem necessidade de tirar o SDCard ou acess\u00e1-la fisicamente. Antes de configur\u00e1-lo, \u00e9 necess\u00e1rio entender seu funcionamento. Funcionamento do U-Boot \u00b6 O U-Boot \u00e9 muito simples. Ele funciona por meio de vari\u00e1veis de ambiente, que podem ser fun\u00e7\u00f5es ou caminhos, al\u00e9m de valores em si, que, quando construidos de um certo modo, conseguem construir a estrutura de boot necess\u00e1ria para ler os arquivos no servidor TFTP j\u00e1 configurado. Inclusive, j\u00e1 existem fun\u00e7\u00f5es definidas para realizar o boot por meio de um servidor, s\u00f3 precisamos garantir que as vari\u00e1veis est\u00e3o corretamente definidas. Vamos come\u00e7ar devagar... Primeiro acesse o kernel com o u-boot. Como n\u00e3o existe nenhum Sistema Operacional, n\u00e3o temos acesso ao servi\u00e7o de ssh , portanto precisamos acessar por screen , como foi feito anteriormente. Mas s\u00f3 isso n\u00e3o conseguimos entrar no painel do U-boot, precisamos reiniciar a placa, e no tempo antes de come\u00e7ar a inicializa\u00e7\u00e3o autom\u00e1tica apertar qualquer tecla. Isso deve parar o processo, e ent\u00e3o voc\u00ea ir\u00e1 se deparar com esse terminal: SOCFPGA_CYCLONE5 # Nele \u00e9 poss\u00edvel visualizar os comandos j\u00e1 definidos com a fun\u00e7\u00e3o de help ou visualizar quais as vari\u00e1veis de ambiente j\u00e1 predefinidas, usando printenv . Outros comando muito importantes para configurar o ambiente s\u00e3o: setenv e saveenv , que ir\u00e3o, respectivamente, receber dois argumentos dizendo qual o nome da vari\u00e1vel e seu valor e defini-la como vari\u00e1vel de ambiente tempor\u00e1ria e receber nenhum argumento e salvar todas as vari\u00e1veis tempor\u00e1rias como permanetes naquela m\u00e1quina. Com essas informa\u00e7\u00f5es em m\u00e3os, vamos partir para a etapa de experimenta\u00e7\u00e3o manual de boot. Experimenta\u00e7\u00e3o Manual \u00b6 Em primeiro lugar, vamos configurar o servidor TFTP para que ele possa ser acessado pela placa. Para isso, precisamos definir o IP da placa e do servidor. Para isso, vamos usar o comando setenv : setenv ipaddr 192.168.0.4 Agora configure o MAC-ADDRESS da placa na vari\u00e1vel ethaddr ; Dica Para descobrir o MAC-ADDRESS da placa, basta acessar o terminal do Linux e executar o comando ifconfig . O MAC-ADDRESS deve ser o mesmo que aparece no terminal do Linux. Para isso basta reiniciar a placa por completo, sem acessar o U-Boot . Volte e execute o passo acima, ou, antes de reiniciar, execute o comando saveenv . Teste a comunica\u00e7\u00e3o com a NUC, usando o comando ping : ping 192.168.0.3 Se a comunica\u00e7\u00e3o for bem sucedida, salve a vari\u00e1vel serverip com o IP da NUC. Agora salve o ambiente criado com o comando saveenv . Reinicie a placa e acesse novamente o U-Boot . Com o comando printenv \u00e9 poss\u00edvel visualizar todas as vari\u00e1veis de ambiente criadas . Boot em TFTP Server \u00b6 Depois de entender o funcionamento do U-Boot , vamos crirar um BootScript para que a placa consiga iniciar o sistema carregando os arquivos do servidor TFTP sem a necessidade de nenhuma configura\u00e7\u00e3o manual. Crie um arquivo boot_script.script Adicione o seguinte conte\u00fado: echo -- Setting Network Variables -- setenv ipaddr [SEU_IP] setenv ethaddr [SEU_MAC_ADDRESS] echo -- Setting Server Ip -- setenv serverip [SEU_IP_DA_NUC] echo -- Setting Server Location File -- setenv tftp-sockit-dir sockit echo -- Setting Server SocKit File Names -- setenv fpga-image soc_system.rbf setenv dtb-image soc_system.dtb echo -- Setting file location in RAM -- setenv fpgadata 0x2000000 setenv fpgadatasize 0x700000 setenv dtbaddr 0x00000100 echo -- Setting FPGA TFTP run scripts -- setenv get-fpgadata 'tftp ${fpgadata} ${tftp-sockit-dir}/${fpga-image}' setenv load-fpga 'fpga load 0 ${fpgadata} ${fpgadatasize}' setenv get-dtb 'tftp ${dtbaddr} ${tftp-sockit-dir}/${dtb-image}' echo -- Run tftp comands -- run get-fpgadata; run load-fpga; run get-dtb; run bridge_enable_handoff; run mmcload; run mmcboot; Depois do arquivo estar completo com as vari\u00e1veis corretamente configuradas, vamos tornar o arquivo em um script que ser\u00e1 executado no U-Boot . Inicie o Intel Embedded Command Shell com o seguinte comando: ~/intelFPGA_lite/18.0/embedded/embedded_command_shell.sh Execute o pr\u00f3ximo comando para compilar o boot_script para o arquivo u-boot.scr : mkimage -A arm -O linux -T script -C none -a 0 -e 0 -n \"TFTP Boot Script\" -d boot_script.script u-boot.scr Copie o arquivo u-boot.scr para a mesma parti\u00e7\u00e3o do SDCard da FPGA que se localiza a imagem do linux ( zImage ) - vai ser necess\u00e1rio desligar a placa e remover o cart\u00e3o de mem\u00f3ria. Insira o SDCard e inicie a placa. Pronto! Seu sistema deve estar funcionando. Agora, sempre que substituir os arquivos .rbf e dtb na NUC e reiniciar a placa, a FPGA ser\u00e1 autom\u00e1ticamente reconfigurada com a nova aplica\u00e7\u00e3o no boot . Motiva\u00e7\u00e3o \u00b6 A nossa motiva\u00e7\u00e3o para realizar este projeto foi como ele \u00e9 altamente aplic\u00e1vel a replica\u00e7\u00e3o de servi\u00e7os constru\u00eddos para SoC-FPGA e no nosso caso, auxiliar a mat\u00e9ria de Embarcados com a possibilidade de automatiza\u00e7\u00e3o dos testes de funcionamento em hardware dos laborat\u00f3rios. Al\u00e9m disso, entender sobre os servi\u00e7os do GitHub para automatiza\u00e7\u00e3o de hooks , protocolos de transfer\u00eancia de arquivos como o TFTP , configura\u00e7\u00e3o e boot do DE10-Standard utilizando u-boot e programar no Quartus estavam entre temas de extremo interesse para todo o grupo. Infraestrutura de integra\u00e7\u00e3o \u00b6 O objetivo da constru\u00e7\u00e3o da infraestrutura de integra\u00e7\u00e3o \u00e9 baixar os arquivos de embarcados de um repositorio no github, coletar os arquivos necessarios e salvar em uma pasta dentro da nuc. Primeiros passos \u00b6 Para come\u00e7armos, vamos primeiro criar um ambiente virtual com o python: virtualenv proj-env source proj-env/bin/activate Nesse projeto utilizaremos flask, por isso precisamos instalar-lo: pip install flask Crie uma pasta para o projeto e crie um arquivo app.py, dentro dele importe as seguintes bibliotecas: from flask import Flask, render_template, request from os import mkdir, path, chdir, system, listdir, getcwd from uuid import uuid4 import shutil O passo a passo desse projeto ser\u00e1: Primeiro o usuario coloca a url do repositorio no formulario e clica no botao enviar Apos o click, o back-end em python realiza as seguintes opera\u00e7\u00f5es: Cria uma pasta repo-download e uma pasta com o nome do usuario Clona o repositorio dentro dessa pasta Dentro da pasta busca o arquivo que termina com a extens\u00e3o .hex e copia para a pasta file-to-test Para esse processo ocorrer \u00e9 necessario criar uma rota dentro do flask. Alem disso todo o processo de criar pastas, entrar e sair de diretorios \u00e9 utilizando a biblioteca OS do python, e a biblioteca shutil para realizar as copias do arquivo. Dentro do arquivo app.py, copie essa parte para criar a rota: app = Flask(__name__) @app.route(\"/\", methods=[\"GET\", \"POST\"]) @app.route(\"/index\", methods=[\"GET\", \"POST\"]) def index(): path_atual = getcwd() if request.method == \"POST\": url_repo = request.form.get(\"url\") username = url_repo.split(\"/\")[3] folder_name = f\"{uuid4()}-{username}\" if path.exists(\"./repos-downloaded/\"): mkdir(path = f\"./repos-downloaded/{folder_name}\") else: mkdir(path=\"./repos-downloaded/\") mkdir(path = f\"./repos-downloaded/{folder_name}\") chdir(f\"./repos-downloaded/{folder_name}\") system(\"echo 'Dentro da pasta'\") system(f\"git clone {url_repo}\") for file in listdir(\"./\"): chdir(file) for file2 in listdir(\"./\"): if file2.endswith(\".hex\"): if path.exists(\"../../../file-to-test/\"): shutil.copy(f\"./{file2}\", f\"../../../file-to-test/{folder_name}.hex\") else: mkdir(path=\"../../../file-to-test\") shutil.copy(f\"./{file2}\", f\"../../../file-to-test/{folder_name}.hex\") chdir(path_atual) return render_template(\"index.html\") if __name__ == '__main__': app.run(host=\"192.168.0.3\", port=8080) Com a rota criada vamos criar o front-end da aplica\u00e7\u00e3o, na raiz do projeto crie uma pasta chamada templates e dentro dela crie um arquivo index.html . Alem disso rode o seguinte comando no terminal para instalar e iniciar o tailwindcss: Warning Para essa parte \u00e9 necessario ter o Node instalado no computador npm install -D tailwindcss npx tailwindcss init Os comandos anteriores devem ter criado um arquivo tailwind.config.js , dentro dele copie a seguinte configura\u00e7\u00e3o: /** @type {import('tailwindcss').Config} */ module.exports = { content: [ \"./templates/**/*.html\", \"./static/src/**/*.js\" ], theme: { extend: {}, }, plugins: [], } Agora crie uma pasta chamada static/src e dentro dela o arquivo input.css . Copie a seguinte configura\u00e7\u00e3o para dentro desse arquivo: @tailwind base; @tailwind components; @tailwind utilities; Dentro do arquivo index.html criado anteriormente, coloque o seguinte codigo html: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Teste CI</title> <link rel=\"stylesheet\" href=\"{{url_for('static',filename='dist/css/output.css')}}\"> </head> <body class=\"bg-slate-100\"> <div class=\"flex min-h-full items-center justify-center py-12 px-4 sm:px-6 lg:px-8\"> <div class=\"w-full max-w-md space-y-8\"> <div> <h2 class=\"mt-6 text-center text-3xl font-bold tracking-tight text-gray-900\">Teste de CI - Computa\u00e7\u00e3o Embarcada</h2> </div> <form class=\"mt-8 space-y-6\" action=\"/index\" method=\"POST\"> <input type=\"hidden\" name=\"remember\" value=\"true\"> <div class=\"-space-y-px rounded-md shadow-sm\"> <div> <label for=\"url-github\" class=\"sr-only\">URL do Repositorio</label> <input id=\"url-github\" name=\"url\" type=\"text\" autocomplete=\"text\" required class=\"relative block w-full appearance-none rounded-none rounded-t-md border border-gray-300 px-3 py-2 text-gray-900 placeholder-gray-500 focus:z-10 focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm\" placeholder=\"URL do Repositorio no Github\"> </div> </div> <div> <button type=\"submit\" class=\"group relative flex w-full justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2\"> Enviar </button> </div> </form> </div> </div> </body> </html> Agora para rodar o back-end em flask rode os seguintes comandos npx tailwindcss -i ./static/src/input.css -o ./static/dist/css/output.css flask run Com isso temos nosso servi\u00e7o de integra\u00e7\u00e3o pronto e funcionando. O servi\u00e7o rodando agora podemos colocalo dentro da NUC e assim iniciar a integra\u00e7\u00e3o com a FPGA","title":"Home"},{"location":"#webserver-com-servidor-tftp-para-automatizacao-de-deploy-de-testes-de-embarcados-na-de10-standard","text":"Alunos: Francisco Pinheiro Janela / Wilgner / Marco Curso: Engenharia da Computa\u00e7\u00e3o / Mecatr\u00f4nica / Mecatr\u00f4nica Semestre: 6 Contato: francisco.pinheiro.janela@gmail.com / placeholder@gmail.com / placeholder@gmail.com Ano: 2022.2","title":"Webserver com Servidor TFTP para automatiza\u00e7\u00e3o de deploy de testes de Embarcados na DE10-Standard"},{"location":"#comecando","text":"Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard NUC ou m\u00e1quina para server Linux Roteador ( modelo usado: tp-link TL-R470T+) Switch ( modelo usado: D-Link DGS-1100-08P) Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf , U-Boot Script , U-Boot TFTP e NFS Laborat\u00f3rios: Linux embarcado , Configurando infra , Extra: configurando rede , Compilando o kernel e Buildroot .","title":"Come\u00e7ando"},{"location":"#montando-a-infraestrutura","text":"Para montar a infraestrutura para este roteiro vamos precisar de um ponto de acesso \u00e0 rede via cabo. Al\u00e9m disso, como a rede do insper \u00e9 protegida, o roteador que estar\u00e1 constituindo nosso kit precisa estar com o MAC Adress configurado na rede interna. Com essas condi\u00e7\u00f5es podemos, ent\u00e3o, ligar toda a fia\u00e7\u00e3o: Roteador - Porta WAN1 deve estar conectada ao ponto de acesso, a porta LAN1 ao Switch e aliment\u00e1-lo com energia Switch - M\u00ednimo de 4 portas, deve aliment\u00e1-lo com energia NUC - Conectar o cabo LAN ao Switch, ligar com Cabo USB a NUC \u00e0 DE10-Standard e aliment\u00e1-la com energia DE10-Standard - Conectar via cabo LAN ao Switch, conectar o USB da NUC, inserir o SDCard configurado com linux kernel e buildroot como filesystem (laborat\u00f3rios previamente feitos) e aliment\u00e1-la com energia Ap\u00f3s tudo conectado, com um palito ou objeto fino, clicar nos pontos de RESET tanto do Roteador, quanto do Switch. O resultado deve ficar similar ao esquema abaixo:","title":"Montando a Infraestrutura"},{"location":"#configurando-a-infraestrtura","text":"Com a infra montada, podemos come\u00e7ar a configurar todos os servi\u00e7os. Vamos come\u00e7ar pela infraestrutura de Rede","title":"Configurando a Infraestrtura"},{"location":"#configurando-a-rede","text":"Conecte seu computador ao switch e configure sua rede para aquela estabelecida no manual do fabricante do Roteador (no caso deste modelo, a rede \u00e9 192.168.0.0/24) Entre na dashboard do roteador em 192.168.0.1 e, acessando pelas credenciais padr\u00f5es indicadas no manual, configure a m\u00e1cara de rede ( Netmask ) para 255.255.240.0 ou /20 Reconfigure seu computador agora para a rede padr\u00e3o do Switch (no caso deste modelo \u00e9 10.0.0.0/8) Acesse o Dashboard (10.90.90.90) com as credenciais default e reconfigure o Switch com o IP: 192.168.0.2/20","title":"Configurando a Rede"},{"location":"#configurando-a-maquina","text":"Depois de configurar tudo de rede, podemos configurar a NUC: Conecte um monitor e um teclado \u00e0 NUC para realizar a instala\u00e7\u00e3o do S.O. Instale o Ubuntu Server 20.04 LTS e durante as configura\u00e7\u00f5es preencher com as informa\u00e7\u00f5es abaixo: hostname: nucsoc login: nucsoc senha: socfpga IP Fixo: 192.168.0.3/20 Verifique se ele consegue pingar 8.8.8.8 . Se n\u00e3o conseguir, descubra como rotear os pacotes corretamente. Verifique se ele consegue pingar www.google.com . Se n\u00e3o conseguir, descubra como resolver as urls corretamente. Verifique se consegue conectar a ela via ssh do seu computador: ssh nucsoc@192.168.0.3 Atualize o apt : sudo apt update && sudo apt upgrade -y Tip Configure a NAT no roteador para poder acessar remotamente a NUC dentro da rede do Insper. Para isso, configure no roteador: Porta externa: 22 Porta interna: 22 IP interno: 192.168.0.3","title":"Configurando a M\u00e1quina"},{"location":"#configurando-a-placa-fpga","text":"Seguindo os tutoriais dos roteiros da mat\u00e9ria, configure o SDCard com todas as parti\u00e7\u00f5es necess\u00e1rias, s\u00e3o elas: U-Boot (configurado com a instala\u00e7\u00e3o do linux embarcado), S.O. e Filesystem (buildroot deve estar instalado com todas as depend\u00eancias de python declaradas mais \u00e0 frente). Com tudo configurado, acesse o terminal da NUC via ssh e com o comando de screen acesse a Placa conectada a ela. sudo screen /dev/ttyUSB0 115200,cs8 Se voc\u00ea configurou NAT, \u00e9 capaz de acessar a screen da FPGA \u00e0 dist\u00e2ncia! Com esse acesso, agora podemos configurar o ip fixo do S.O. da FPGA: Acesse a pasta /etc/init.d/ Crie um arquivo chamado S60MAC.sh Info Todo o arquivo dentro desta pasta que come\u00e7a com S mai\u00fasculo \u00e9 executado durante o boot do S.O. Acessando o arquivo com vi , coloque o seguinte c\u00f3digo: #!/bin/bash case \" $1 \" in start ) printf \"Setting ip: \" /sbin/ifconfig eth0 192 .168.0.40 netmask 255 .255.240.0 up [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" route add default gw 192 .168.0.1 ;; * ) exit 1 ;; esac O c\u00f3digo acima ir\u00e1 configurar a rede da placa para que esta tenha um ip fixo de acordo com as configura\u00e7\u00f5es de rede feitas. Transforme o arquivo acima em um execut\u00e1vel chmod +x S60MAC.sh Reinicie a FPGA para aplicar as mudan\u00e7as Pronto! Agora temos toda a inffraestrutura configurada e podemos come\u00e7ar a construir nosso servidor de TFTP. Warning N\u00e3o continue para os pr\u00f3ximos passos sem toda a infraestrutura montada e configurada","title":"Configurando a Placa FPGA"},{"location":"#servidor-tftp","text":"Antes de come\u00e7ar a constru\u00e7\u00e3o do servidor, \u00e9 bom entender como ele funciona.","title":"Servidor TFTP"},{"location":"#conceito-e-diretorio","text":"Um servidor TFTP \u00e9 um servi\u00e7o dispon\u00edvel em um host que permite ao server buscar arquivos, baseado no protocolo de comunica\u00e7\u00e3o TFTP. Para esta aplica\u00e7\u00e3o, o servidor ser\u00e1 utilizado como fonte dos arquivos principais para configurar a FPGA da DE10-Standard, mas poderia tamb\u00e9m ser usado para buscar as imagens dos Sistemas Operacionais e BootScripts, al\u00e9m de parear muito bem com o servi\u00e7o de NFS (Network File System) para que o File System da DE10 pudesse ser remoto. Com tais funcionalidades, poder\u00edamos chegar em uma constru\u00e7\u00e3o de diret\u00f3rio assim: /srv \u251c\u2500\u2500 nfs \u2502 \u251c\u2500\u2500 angstrom-v2014.12 \u2502 \u2502 \u2514\u2500\u2500 root file system extracted from build tools .tar.gx archive \u2502 \u251c\u2500\u2500 ubuntu-core \u2502 \u2502 \u2514\u2500\u2500 root file system extracted from build tools .tar.gx archive \u2514\u2500\u2500 tftp \u251c\u2500\u2500 bootscripts \u2502 \u251c\u2500\u2500 sockit-angstrom.scr \u2502 \u251c\u2500\u2500 sockit-angstrom.script \u2502 \u251c\u2500\u2500 sockit-ubuntu.scr \u2502 \u2514\u2500\u2500 sockit-ubuntu.script \u251c\u2500\u2500 kernel \u2502 \u251c\u2500\u2500 kernel-3.10-ltsi \u2502 \u2502 \u2514\u2500\u2500 zImage \u2502 \u251c\u2500\u2500 kernel-4.4 \u2502 \u2502 \u2514\u2500\u2500 zImage \u251c\u2500\u2500 my-custom-board \u2502 \u251c\u2500\u2500 my-custom.dtb \u2502 \u2514\u2500\u2500 my-custom.rbf \u2514\u2500\u2500 sockit \u251c\u2500\u2500 soc_system.dtb \u2514\u2500\u2500 soc_system.rbf Como neste tutorial s\u00f3 ser\u00e1 usado o espa\u00e7o destinado aos arquivos do quartus, abaixo est\u00e1 uma tabela onde estes se encontram no output de uma compila\u00e7\u00e3o do projeto criado pelo aplicativo: Item Source File Location Copy to server directory Compressed FPGA configuration file Quartus GHRD Build /sockit_ghrd/output_files/soc_system.rbf soc_system.rbf Device Tree Blob file Quartus GHRD Build /sockit_ghrd/soc_system.dtb soc_system.dtb","title":"Conceito e Diret\u00f3rio"},{"location":"#setup-do-servidor-tftp","text":"Para come\u00e7ar com o setup, vamos instalar o pr\u00f3prio servi\u00e7o de TFTP: sudo apt-get install tftpd-hpa Note O servidor deve come\u00e7ar autom\u00e1ticamente ap\u00f3s ser instalado, verifique por meio do seguinte comando: sudo service tftpd-hpa status Caso n\u00e3o tenha iniciado, inicie-o com o comando: sudo service tftpd-hpa start Em seguida crie os reposit\u00f3rios necess\u00e1rios para armazenar os arquivos .dtb e .rbf como mostrado na \u00e1rvore de diret\u00f3rios acima. Depois de ter organizado todo o diret\u00f3rio, precisa indicar para o servidor que s\u00e3o estas pastas que ser\u00e3o usadas. Para isso deve editar a vari\u00e1vel TFTP_DIRECTORY , localizada em /etc/default/tftpd-hpa . Ela deve possuir um diret\u00f3rio padr\u00e3o, mas deve configur\u00e1-lo para aquele criado acima. TFTP_DIRECTORY = \"/srv/tftp/\" Verifique o status novamente. Se estiver rodadndo ( start/running ), pode proceguir para a pr\u00f3xima etapa, caso n\u00e3o, provavelmente o diret\u00f3rio configurado n\u00e3o foi encontrado pelo servidor. Por \u00faltimo, copie os arquivos .dtb e .rbf para o reposit\u00f3rio e reinicie o servidor: sudo service tftpd-hpa restart","title":"Setup do Servidor TFTP"},{"location":"#carregando-o-u-boot","text":"Depois de configurar toda a infraestrutura da DE10-Standard com os laborat\u00f3rios feitos em aula, vamos entender uma ferramenta essencial para o funcionamento do Linux Embarcado: o U-Boot . Quando o kernel Linux \u00e9 instalado, \u00e9 criada uma parti\u00e7\u00e3o no SDCard com esse servi\u00e7o de \"pre-boot\" . Nele, s\u00e3o definidas as configura\u00e7\u00f5es iniciais da placa para receber e organizar tanto a imagem, os arquivos da FPGA e o File System e por meio de Scripts de boot, iniciar o S.O. adequadamente. Esse \"pre-boot\" \u00e9 extremamente poderoso para a nossa aplica\u00e7\u00e3o, pois podemos configurar toda a estrutura do S.O. sem necessidade de tirar o SDCard ou acess\u00e1-la fisicamente. Antes de configur\u00e1-lo, \u00e9 necess\u00e1rio entender seu funcionamento.","title":"Carregando o U-Boot"},{"location":"#funcionamento-do-u-boot","text":"O U-Boot \u00e9 muito simples. Ele funciona por meio de vari\u00e1veis de ambiente, que podem ser fun\u00e7\u00f5es ou caminhos, al\u00e9m de valores em si, que, quando construidos de um certo modo, conseguem construir a estrutura de boot necess\u00e1ria para ler os arquivos no servidor TFTP j\u00e1 configurado. Inclusive, j\u00e1 existem fun\u00e7\u00f5es definidas para realizar o boot por meio de um servidor, s\u00f3 precisamos garantir que as vari\u00e1veis est\u00e3o corretamente definidas. Vamos come\u00e7ar devagar... Primeiro acesse o kernel com o u-boot. Como n\u00e3o existe nenhum Sistema Operacional, n\u00e3o temos acesso ao servi\u00e7o de ssh , portanto precisamos acessar por screen , como foi feito anteriormente. Mas s\u00f3 isso n\u00e3o conseguimos entrar no painel do U-boot, precisamos reiniciar a placa, e no tempo antes de come\u00e7ar a inicializa\u00e7\u00e3o autom\u00e1tica apertar qualquer tecla. Isso deve parar o processo, e ent\u00e3o voc\u00ea ir\u00e1 se deparar com esse terminal: SOCFPGA_CYCLONE5 # Nele \u00e9 poss\u00edvel visualizar os comandos j\u00e1 definidos com a fun\u00e7\u00e3o de help ou visualizar quais as vari\u00e1veis de ambiente j\u00e1 predefinidas, usando printenv . Outros comando muito importantes para configurar o ambiente s\u00e3o: setenv e saveenv , que ir\u00e3o, respectivamente, receber dois argumentos dizendo qual o nome da vari\u00e1vel e seu valor e defini-la como vari\u00e1vel de ambiente tempor\u00e1ria e receber nenhum argumento e salvar todas as vari\u00e1veis tempor\u00e1rias como permanetes naquela m\u00e1quina. Com essas informa\u00e7\u00f5es em m\u00e3os, vamos partir para a etapa de experimenta\u00e7\u00e3o manual de boot.","title":"Funcionamento do U-Boot"},{"location":"#experimentacao-manual","text":"Em primeiro lugar, vamos configurar o servidor TFTP para que ele possa ser acessado pela placa. Para isso, precisamos definir o IP da placa e do servidor. Para isso, vamos usar o comando setenv : setenv ipaddr 192.168.0.4 Agora configure o MAC-ADDRESS da placa na vari\u00e1vel ethaddr ; Dica Para descobrir o MAC-ADDRESS da placa, basta acessar o terminal do Linux e executar o comando ifconfig . O MAC-ADDRESS deve ser o mesmo que aparece no terminal do Linux. Para isso basta reiniciar a placa por completo, sem acessar o U-Boot . Volte e execute o passo acima, ou, antes de reiniciar, execute o comando saveenv . Teste a comunica\u00e7\u00e3o com a NUC, usando o comando ping : ping 192.168.0.3 Se a comunica\u00e7\u00e3o for bem sucedida, salve a vari\u00e1vel serverip com o IP da NUC. Agora salve o ambiente criado com o comando saveenv . Reinicie a placa e acesse novamente o U-Boot . Com o comando printenv \u00e9 poss\u00edvel visualizar todas as vari\u00e1veis de ambiente criadas .","title":"Experimenta\u00e7\u00e3o Manual"},{"location":"#boot-em-tftp-server","text":"Depois de entender o funcionamento do U-Boot , vamos crirar um BootScript para que a placa consiga iniciar o sistema carregando os arquivos do servidor TFTP sem a necessidade de nenhuma configura\u00e7\u00e3o manual. Crie um arquivo boot_script.script Adicione o seguinte conte\u00fado: echo -- Setting Network Variables -- setenv ipaddr [SEU_IP] setenv ethaddr [SEU_MAC_ADDRESS] echo -- Setting Server Ip -- setenv serverip [SEU_IP_DA_NUC] echo -- Setting Server Location File -- setenv tftp-sockit-dir sockit echo -- Setting Server SocKit File Names -- setenv fpga-image soc_system.rbf setenv dtb-image soc_system.dtb echo -- Setting file location in RAM -- setenv fpgadata 0x2000000 setenv fpgadatasize 0x700000 setenv dtbaddr 0x00000100 echo -- Setting FPGA TFTP run scripts -- setenv get-fpgadata 'tftp ${fpgadata} ${tftp-sockit-dir}/${fpga-image}' setenv load-fpga 'fpga load 0 ${fpgadata} ${fpgadatasize}' setenv get-dtb 'tftp ${dtbaddr} ${tftp-sockit-dir}/${dtb-image}' echo -- Run tftp comands -- run get-fpgadata; run load-fpga; run get-dtb; run bridge_enable_handoff; run mmcload; run mmcboot; Depois do arquivo estar completo com as vari\u00e1veis corretamente configuradas, vamos tornar o arquivo em um script que ser\u00e1 executado no U-Boot . Inicie o Intel Embedded Command Shell com o seguinte comando: ~/intelFPGA_lite/18.0/embedded/embedded_command_shell.sh Execute o pr\u00f3ximo comando para compilar o boot_script para o arquivo u-boot.scr : mkimage -A arm -O linux -T script -C none -a 0 -e 0 -n \"TFTP Boot Script\" -d boot_script.script u-boot.scr Copie o arquivo u-boot.scr para a mesma parti\u00e7\u00e3o do SDCard da FPGA que se localiza a imagem do linux ( zImage ) - vai ser necess\u00e1rio desligar a placa e remover o cart\u00e3o de mem\u00f3ria. Insira o SDCard e inicie a placa. Pronto! Seu sistema deve estar funcionando. Agora, sempre que substituir os arquivos .rbf e dtb na NUC e reiniciar a placa, a FPGA ser\u00e1 autom\u00e1ticamente reconfigurada com a nova aplica\u00e7\u00e3o no boot .","title":"Boot em TFTP Server"},{"location":"#motivacao","text":"A nossa motiva\u00e7\u00e3o para realizar este projeto foi como ele \u00e9 altamente aplic\u00e1vel a replica\u00e7\u00e3o de servi\u00e7os constru\u00eddos para SoC-FPGA e no nosso caso, auxiliar a mat\u00e9ria de Embarcados com a possibilidade de automatiza\u00e7\u00e3o dos testes de funcionamento em hardware dos laborat\u00f3rios. Al\u00e9m disso, entender sobre os servi\u00e7os do GitHub para automatiza\u00e7\u00e3o de hooks , protocolos de transfer\u00eancia de arquivos como o TFTP , configura\u00e7\u00e3o e boot do DE10-Standard utilizando u-boot e programar no Quartus estavam entre temas de extremo interesse para todo o grupo.","title":"Motiva\u00e7\u00e3o"},{"location":"#infraestrutura-de-integracao","text":"O objetivo da constru\u00e7\u00e3o da infraestrutura de integra\u00e7\u00e3o \u00e9 baixar os arquivos de embarcados de um repositorio no github, coletar os arquivos necessarios e salvar em uma pasta dentro da nuc.","title":"Infraestrutura de integra\u00e7\u00e3o"},{"location":"#primeiros-passos","text":"Para come\u00e7armos, vamos primeiro criar um ambiente virtual com o python: virtualenv proj-env source proj-env/bin/activate Nesse projeto utilizaremos flask, por isso precisamos instalar-lo: pip install flask Crie uma pasta para o projeto e crie um arquivo app.py, dentro dele importe as seguintes bibliotecas: from flask import Flask, render_template, request from os import mkdir, path, chdir, system, listdir, getcwd from uuid import uuid4 import shutil O passo a passo desse projeto ser\u00e1: Primeiro o usuario coloca a url do repositorio no formulario e clica no botao enviar Apos o click, o back-end em python realiza as seguintes opera\u00e7\u00f5es: Cria uma pasta repo-download e uma pasta com o nome do usuario Clona o repositorio dentro dessa pasta Dentro da pasta busca o arquivo que termina com a extens\u00e3o .hex e copia para a pasta file-to-test Para esse processo ocorrer \u00e9 necessario criar uma rota dentro do flask. Alem disso todo o processo de criar pastas, entrar e sair de diretorios \u00e9 utilizando a biblioteca OS do python, e a biblioteca shutil para realizar as copias do arquivo. Dentro do arquivo app.py, copie essa parte para criar a rota: app = Flask(__name__) @app.route(\"/\", methods=[\"GET\", \"POST\"]) @app.route(\"/index\", methods=[\"GET\", \"POST\"]) def index(): path_atual = getcwd() if request.method == \"POST\": url_repo = request.form.get(\"url\") username = url_repo.split(\"/\")[3] folder_name = f\"{uuid4()}-{username}\" if path.exists(\"./repos-downloaded/\"): mkdir(path = f\"./repos-downloaded/{folder_name}\") else: mkdir(path=\"./repos-downloaded/\") mkdir(path = f\"./repos-downloaded/{folder_name}\") chdir(f\"./repos-downloaded/{folder_name}\") system(\"echo 'Dentro da pasta'\") system(f\"git clone {url_repo}\") for file in listdir(\"./\"): chdir(file) for file2 in listdir(\"./\"): if file2.endswith(\".hex\"): if path.exists(\"../../../file-to-test/\"): shutil.copy(f\"./{file2}\", f\"../../../file-to-test/{folder_name}.hex\") else: mkdir(path=\"../../../file-to-test\") shutil.copy(f\"./{file2}\", f\"../../../file-to-test/{folder_name}.hex\") chdir(path_atual) return render_template(\"index.html\") if __name__ == '__main__': app.run(host=\"192.168.0.3\", port=8080) Com a rota criada vamos criar o front-end da aplica\u00e7\u00e3o, na raiz do projeto crie uma pasta chamada templates e dentro dela crie um arquivo index.html . Alem disso rode o seguinte comando no terminal para instalar e iniciar o tailwindcss: Warning Para essa parte \u00e9 necessario ter o Node instalado no computador npm install -D tailwindcss npx tailwindcss init Os comandos anteriores devem ter criado um arquivo tailwind.config.js , dentro dele copie a seguinte configura\u00e7\u00e3o: /** @type {import('tailwindcss').Config} */ module.exports = { content: [ \"./templates/**/*.html\", \"./static/src/**/*.js\" ], theme: { extend: {}, }, plugins: [], } Agora crie uma pasta chamada static/src e dentro dela o arquivo input.css . Copie a seguinte configura\u00e7\u00e3o para dentro desse arquivo: @tailwind base; @tailwind components; @tailwind utilities; Dentro do arquivo index.html criado anteriormente, coloque o seguinte codigo html: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Teste CI</title> <link rel=\"stylesheet\" href=\"{{url_for('static',filename='dist/css/output.css')}}\"> </head> <body class=\"bg-slate-100\"> <div class=\"flex min-h-full items-center justify-center py-12 px-4 sm:px-6 lg:px-8\"> <div class=\"w-full max-w-md space-y-8\"> <div> <h2 class=\"mt-6 text-center text-3xl font-bold tracking-tight text-gray-900\">Teste de CI - Computa\u00e7\u00e3o Embarcada</h2> </div> <form class=\"mt-8 space-y-6\" action=\"/index\" method=\"POST\"> <input type=\"hidden\" name=\"remember\" value=\"true\"> <div class=\"-space-y-px rounded-md shadow-sm\"> <div> <label for=\"url-github\" class=\"sr-only\">URL do Repositorio</label> <input id=\"url-github\" name=\"url\" type=\"text\" autocomplete=\"text\" required class=\"relative block w-full appearance-none rounded-none rounded-t-md border border-gray-300 px-3 py-2 text-gray-900 placeholder-gray-500 focus:z-10 focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm\" placeholder=\"URL do Repositorio no Github\"> </div> </div> <div> <button type=\"submit\" class=\"group relative flex w-full justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2\"> Enviar </button> </div> </form> </div> </div> </body> </html> Agora para rodar o back-end em flask rode os seguintes comandos npx tailwindcss -i ./static/src/input.css -o ./static/dist/css/output.css flask run Com isso temos nosso servi\u00e7o de integra\u00e7\u00e3o pronto e funcionando. O servi\u00e7o rodando agora podemos colocalo dentro da NUC e assim iniciar a integra\u00e7\u00e3o com a FPGA","title":"Primeiros passos"}]}